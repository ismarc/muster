* Muster Language Specification
** Introduction
Muster is an implicitly parallel, declarative data processing language.  It is organized by connecting data sources
(streams or collections) to a series of operations.  There are no variables in Muster.  Instead, a name is defined as
having a particular value (a block to be evaluated later, a block to be evaluated now or a bare value).  There are no
explicit loops, instead having an implicit looping mechanism.  Given a declaration that takes a single value, when called
with a list as input, the declaration will be called for each entry in the list.  There are no if/else style conditionals.
Instead, all conditionals are done via pattern matching.  The pattern matching system allows matching on any type identifier,
size/element decomposition and explicit value matching.  There is no concept of null or empty values.  Collections and streams
can have no elements (be empty), and a declaration can return no value.  However, if a declaration that returns no value is
used as the input to another declaration (via definition or directly), the declaration is never called.  Muster uses a
capabilities based type system.  A declaration creates a type based on the definitions contained in it.  Any declaration that
has at least the definitions required can be used as that type.  Declarations can be nested, but definitions cannot.  Nested
declarations provide namespacing capabilities.  Multi-file support for declarations exist via the import command

define my_namespace := declare {
  define sub_namespace := import system;
  define another_namespace := import "MyFile.mtr";
};

** Lexican elements
*** Comments
Comments are delimited by /* ... */ and can span multiple lines.  Comments do not nest.

*** Identifiers
Identifiers name program entities, such as definitions.  It is a sequence of one or more letteres and digits.  The first
character must be a letter.

identifier = letter { letter | unicode_digit } .

*** Keywords
There are very few reserved keywords in Muster.  They are:
 - define
 - declare
 - import
 - case
 - serial

*** Operators and Delimiters
The set of operators and delimiters are:

 + &  := ( )
 - |  <  [ ]
 * ^  >  { }
 / << "  , :
 % >>    . ;

*** Integer literals
An integer literal is a sequence of digits that represent an integer constant.

decimal_digit = "0" ... "9" .
octal_digit   = "0" ... "7" .
hex_digit     = "0" ... "9" | "A" ... "F" | "a" ... "f" .

int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( "1" ... "9" ) { decimal_digit } .
octal_lit   = "0" { octal_digit } .
hex_lit     = "0" "x" hex_digit { hex_digit } .

*** Floating-point literals
A floating point literal is a decimal representation of a floating point constant.

float_lit = decimals "." [ decimals ] |
            "." decimals
decimals  = decimal_digit { decimal_digit } .

*** String literals
A string literal represents a string constant obtained from a concatenating a sequence of characters.

string_lit = `"` { unicode_char | newline } `"`

** Blocks
A block is a possibly empty sequence of declarations, definitions and statements within matching brace brackets.  Evaluation
of the block is determined based on its use.  It can be used to create a declaration, to create a definition or to create
a pattern matching block.

Block         = "{" StatementList "}" .
StatementList = { Statement ";" } .

*** Declaration Blocks
A declaration is a block that takes 0 or more values as input and evaluates to 0 or more values.  A declaration block is not
evaluated when it is declared, only when used within an expression.

Declaration   = "declare" Signature Block .
Signature     = Parameters [ ":" Result ] .
Parameters    = "(" [ ParameterList [ "," ]] ")" .
Result        = Parameters | Type .
ParameterList = ParameterDecl { "," ParameterDecl } .
ParameterDecl = [ identifier ":" Type ] .
Type          = identifier [ "(" identifier ")" ] .

declare (a: system.Stream, b: MyType): List(String) {
  (a, b);
};

*** Serial Blocks
A serial block indicates that every statement contained in the block should be executed serially, rather than in parallel.
Normally, individual statements are executed in sequence, but each statement may be evaluated in parallel.  Serial blocks
insure that this does not happen.

Serial = "serial" Block .

serial {
  system.out.println < ["Hello", "World"]
}

*** Case Blocks
A case block uses pattern matching and decompisition to produce conditional results.  It takes 0 or more values as input
and returns 0 or more values.  If the pattern signature is matched for the input to the current block, the body is executed.
Use of case blocks can result in unwieldy looking code, so it is strongly suggested to wrap then in a declaration, preferrably
one assigned to a definition.

Case             = "case" PatternSignature Block .
Pattern          = PatternSignature [ ":" Result ] .
PatternSignature = "(" [ PatternList [ "," ]] ")" .
Result           = PatternSignature | Type .
PatternList      = PatternSpec { "," PatternDecl } .
PatternSpec      = constant | PatternDecl .
PatternDecl      = [ PatternSpec ":" Type ] .
Type             = identifier [ "(" identifier ")" ] .

declare (a: String): AnotherType {
  case (e: MyType): AnotherType {

  };
  case ("x"): AnotherType {
    
  };
  case ("x", foo: Bar): AnotherType {

  };
};

*** Definitions
A definition is a label applied to a value.  If the value is a statement or block, it is not evaluated at the time the definition
is created, it is only evaluated when it is used in a statement.

Definition = "define" identifier ":" Type ":=" Value
Value      = Case | Serial | Declaration | Constant | Statement .
Type       = identifier [ "(" identifier ")" ] .

define x: system.Stream := declare (a: system.Stream): system.Stream {
  a;
};

** Types
Type specifications in Muster are different than other systems.  Types are not explicitly created, every definition is an implicit
type.  This mechanism also means that there are no "built-in" types, they are all wrapped by system definitions.  The only type
that can be said to exist without a definition is Constant, which includes constant strings and numbers.  These are automatically
coerced into the system provided type (system.String, system.Number, system.Integer, system.Float).  Declarations form a 'template'
for the requirments of a type.

Given the following:

/* Define Foo as a declaration with bar and baz definitions */
define Foo := declare () {
  define bar: system.String := declare (): system.String { "a"; };
  define baz: system.Number := 5;
  define oh: Foo := declare (): Foo {
    define b: system.String := "e";
    Foo;
  };
};

/* Define Bar as a declaration with bar and baz definitions */
define Bar := declare () {
  define bar: system.String := "b";
  define baz: system.Number := 10;
  define oh: Foo := declare (): Foo {
    define a: system.String := "e";
    Foo;
  };
};

/* Define Baz as a declaration with bar, baz and bam definitions */
define Baz := declare () {
  define bar: system.String := "c";
  define baz: system.Number := 5;
  define bam: system.String := "d";
  define oh: Foo := declare (): Foo {
    define d: system.String := "e";
    Foo;
  };
};

/* Define call as a declaration that takes a type of Foo */
define call := declare (a: Foo) {};

/* Define bunk as a declaration that takes a type of Baz */
define bunk := declare (a: Baz) {};

/* All 3 are valid */
call < Foo;
call < Bar;
call < Baz;

/* Both are invalid, they fail the type checks */
call < Foo;
call < Bar;

When a definition is used as a type, the type that is generated is the components of the definition.  Only the top-level
definitions are considered for the type check.  As can be seen, the 'oh' definition in each one differs on what it contains,
but would not result in a compile error.
